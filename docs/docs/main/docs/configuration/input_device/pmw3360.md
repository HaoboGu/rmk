# PMW3360 Optical Mouse Sensor

PMW3360 is a optical mouse sensor.

::: note

- PMW3360 uses full-duplex SPI. (MISO/ MOSI)
- `motion` pin is optional. If omitted, the sensor is polled.
- Only Nrf and RP2040 are supported now. TODO: Find out which boards work, actually every board with an SPIBus implementation should

:::

## `toml` configuration

```toml
[[input_device.pmw3360]]
name = "trackball0"

spi.instance = "SPI0"
spi.sck = "PIN_18"
spi.mosi = "PIN_19"
spi.miso = "PIN_16"
spi.cs = "PIN_17"
spi.tx_dma = "DMA_CH2" # omit for nrf52
spi.rx_dma = "DMA_CH3" # omit for nrf52

motion = "PIN_20" # Optional. If omitted, the sensor is polled.

cpi = 1600
rot_trans_angle = -15
liftoff_dist = 8
invert_x = true
# invert_y = true
# swap_xy = true
```

### Split

To add the sensor to the central or peripheral use 
```toml
[[split.central.input_device.pmw3360]]
name = ...

# resp.
[[split.peripheral.input_device.pmw3360]]
name = ...
```

## Rust configuration

Define a `PointingDevice` and add it to `run_devices!` macro.
For a split keyboard this must be added to the file (`central.rs` or `peripheral.rs`) corresponding to the side the sensor is connected to.

::: Warning

For nrf52 chips you need to add an interrupt for the used SPI. For expample when using SPI2:
```rust
use ::embassy_nrf::spim;

bind_interrupts!(struct Irqs {
    ...
    SPI2 => spim::InterruptHandler<peripherals::SPI2>;
});
```

:::

```rust
    use embassy_rp::spi::{Spi, Config, Polarity, Phase};
    use embassy_rp::gpio::{Level, Output, Pull};
    use rmk::input_device::pointing::PointingDevice;
    use rmk::input_device::pmw3360::Pmw3360Config;

    let mut spi_cfg = Config::default();
    // // MODE_3 = Polarity::IdleHigh + Phase::CaptureOnSecondTransition
    spi_cfg.polarity = Polarity::IdleHigh;
    spi_cfg.phase = Phase::CaptureOnSecondTransition;
    spi_cfg.frequency = 2_000_000;

    // // Create GPIO pins
    let pmw3360_sck = p.PIN_18;
    let pmw3360_mosi = p.PIN_19;
    let pmw3360_miso = p.PIN_16;
    let pmw3360_cs = Output::new(p.PIN_17, Level::High);
    let pmw3360_irq = Input::new(p.PIN_20, Pull::Up);

    // Create the SPI bus
    let pmw3360_spi = Spi::new(p.SPI0, pmw3360_sck,pmw3360_mosi,pmw3360_miso, p.DMA_CH2, p.DMA_CH3, spi_cfg);

    // Initialize PMW3360 mouse sensor
    let pmw3360_config = Pmw3360Config {
        res_cpi: 1600,
        rot_trans_angle: -15,
        liftoff_dist: 0x08,
        swap_xy: false,
        invert_x: true,
        invert_y: false,
        ..Default::default()
    };

    // Create the sensor device
    let mut PointingDevice::<Pmw3360<_, _, _>>::new(pmw3360_spi, pmw3360_cs, Some(pmw3360_irq), pmw3360_config);
```

And define a `PointingProcessor` and add it to `run_processor_chain!` macro to process the events.

::: warning

This should be added to the `central.rs`-File even if the sensor is on split peripheral.

:::

```rust
    use rmk::input_device::pointing::PointingProcessor;

    let mut pmw3360_processor = PointingProcessor::new(&keymap);

    run_processor_chain! {
        EVENT_CHANNEL => [pmw3360_processor],
    },
```

