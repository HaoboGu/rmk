# PMW3610 Optical Mouse Sensor

PMW3610 is a low‑power optical mouse sensor.

::: note

- Currently, only implemented for nRF52 and RP2040 with a single-wire (SDIO) half-duplex SPI.
- Set `motion` pin for better power efficiency. If omitted, the sensor is polled.
- By default, report rate is limited to 125 Hz to prevent flooding the event channel, which causes latency issues especially over BLE.

:::

## `toml` configuration

::: warning

`spi.mosi` and `spi.miso` must be the same pin, or one of them empty.

:::

```toml
[[input_device.pmw3610]]
name = "trackball0"
id = 0 # optional number between 0-255. Ids are used for debug prints. Set to 0 if omitted.

spi.instance = "bitbang0"
spi.sck = "P0_05"
spi.mosi = "P0_04"
spi.miso = "P0_04"
spi.cs = "P0_09"
# or spi = { instance = "bitbang0", sck = "P0_05", mosi = "P0_04", miso = "P0_04", cs = "P0_09" }

motion = "P0_02" # Optional. If omitted, the sensor is polled.

report_hz = 125 # Optional: Report rate in Hz

force_awake = false
smart_mode = true
cpi = 800
# invert / swap axis on a sensor level
invert_x = true
# invert_y = true
# swap_xy = true
# invert / swap axis in software (in PointingProcessor)
# proc_invert_x = true
# proc_invert_y = true
# proc_swap_xy = true

```

### Split

To add the sensor to the central or peripheral use
```toml
[[split.central.input_device.pmw3610]]
name = ...

# resp.
[[split.peripheral.input_device.pmw3610]]
name = ...
```

## Rust configuration

Define a `PointingDevice` and add it to `run_all!` macro.
For a split keyboard this must be added to the file (`central.rs` or `peripheral.rs`) corresponding to the side the sensor is connected to.

```rust
use embassy_rp::gpio::{Output, Flex, Level};
use rmk::input_device::pmw3610::{BitBangSpiBus, Pmw3610, Pmw3610Config};
use rmk::input_device::pointing::PointingDevice;

let pmw3610_config = Pmw3610Config {
    res_cpi: 800,
    // force_awake: true,
    smart_mode: true,
    swap_xy: true,
    // invert_x: true,
    // invert_y: true,
    ..Default::default()
};

let pmw3610_sck = Output::new(p.P0_05, Level::High, OutputDrive::Standard);
let pmw3610_sdio = Flex::new(p.P0_04);
let pmw3610_cs = Output::new(p.P0_09, Level::High, OutputDrive::Standard);
let pmw3610_motion = Some(Input::new(p.P0_02, Pull::Up));
// or if you want to omit the motion pin:
// let pmw3610_motion = Option::<Input<'static>>::None;

let pmw3610_spi = BitBangSpiBus::new(pmw3610_sck, pmw3610_sdio);

const POINTING_DEV_ID: u8 = 0 // this ID can be anything form 0-255. Just make sure you don't use the same number twice for different sensors to avoid confusion. 
let mut pmw3610_device = PointingDevice::<Pmw3610<_, _, _>>::new(
    POINTING_DEV_ID
    pmw3610_spi,
    pmw3610_cs,
    pmw3610_motion,
    pmw3610_config,
);

// If you want to customize the report rate (Hz):
// let mut pmw3610_device = Pmw3610Device::with_report_hz(
//     POINTING_DEV_ID
//     pmw3610_spi,
//     pmw3610_cs,
//     pmw3610_motion,
//     pmw3610_config,
//     125,
// );

run_all!(matrix, pmw3610_device),
```

And define a `PointingProcessor` and add it to `run_all!` macro to process the events.

::: warning

This should be added to the `central.rs`-File even if the sensor is on split peripheral.

:::

```rust
use rmk::input_device::pointing::{
    PointingProcessor, PointingProcessorConfig, PointingMode, ScrollConfig, SniperConfig
};

let pmw3360_proc_config = PointingProcessorConfig {
    // invert_x: true, // invert axis if necessary
    // invert_y: true,
    // swap_xy: true,
    ..Default::default()
};

let mut pmw3360_processor = PointingProcessor::new(&keymap, pmw3360_proc_config);

run_all!(pmw3610_processor, /* other processors and devices */)
```

## Per-Layer Pointing Modes

You can configure different pointing behaviors for each layer. This allows you to use the same pointing device for different purposes:

- **Cursor mode** (default): Normal mouse movement
- **Scroll mode**: Converts movement to scroll wheel/pan
- **Sniper mode**: Precision mode with reduced sensitivity

### Example: Three-Mode Configuration

```rust
use rmk::input_device::pointing::{
    PointingProcessor, PointingProcessorConfig, PointingMode, ScrollConfig, SniperConfig
};

let mut pointing_processor = PointingProcessor::new(&keymap, PointingProcessorConfig::default());

// Configure per-layer modes
pointing_processor
    .set_layer_mode(0, PointingMode::Cursor)                    // Layer 0: Normal cursor
    .set_layer_mode(1, PointingMode::Scroll(ScrollConfig {
        divisor_x: 8,  // Pan sensitivity (higher = slower horizontal scrolling)
        divisor_y: 8,  // Wheel sensitivity (higher = slower vertical scrolling)
    }))                                                          // Layer 1: Scroll mode
    .set_layer_mode(2, PointingMode::Sniper(SniperConfig {
        divisor: 4,    // Precision divisor (higher = slower, more precise)
    }));                                                         // Layer 2: Sniper mode
```

### Usage in Keymap

Use momentary layer switches (`MO(n)`) or layer toggles (`TG(n)`) to activate different pointing modes:

```rust
// In your keymap:
// - Hold MO(1) to activate scroll mode (trackball becomes scroll wheel)
// - Hold MO(2) to activate sniper mode (precision aiming)
// - Release to return to normal cursor mode

let keymap = [
    // Layer 0 (Cursor mode)
    [KC_A, KC_B, MO(1), MO(2), ...],

    // Layer 1 (Scroll mode - activated by MO(1))
    [KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, ...],

    // Layer 2 (Sniper mode - activated by MO(2))
    [KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, ...],
];
```

### Mode Details

#### Cursor Mode
- Direct 1:1 mapping of sensor movement to cursor movement
- Best for general navigation and pointer control

#### Scroll Mode
- X-axis movement → horizontal pan
- Y-axis movement → vertical scroll wheel
- `divisor_x` and `divisor_y` control sensitivity
- Higher divisor = slower, more controlled scrolling
- Recommended values: 4-16 (default: 8)

#### Sniper Mode
- Reduces movement speed for precision aiming
- Same divisor applies to both X and Y axes
- Higher divisor = slower, more precise movement
- Recommended values: 2-8 (default: 4)
- Useful for games, CAD, or detailed work

### Alternative: Configure All Layers at Once

```rust
use rmk::input_device::pointing::{PointingMode, ScrollConfig, SniperConfig};

// Assuming 4 layers
let layer_modes = [
    PointingMode::Cursor,                                    // Layer 0
    PointingMode::Scroll(ScrollConfig::default()),           // Layer 1
    PointingMode::Sniper(SniperConfig { divisor: 4 }),       // Layer 2
    PointingMode::Cursor,                                    // Layer 3
];

let pointing_processor = PointingProcessor::new(&keymap, PointingProcessorConfig::default())
    .with_layer_modes(layer_modes);
```

::: tip
When switching between layers, the motion accumulator is automatically reset to prevent unexpected jumps. This ensures smooth transitions between different pointing modes.
:::
