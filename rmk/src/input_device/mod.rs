//! Input device module for RMK
//!
//! This module defines the `InputDevice` trait, `InputProcessor` trait, `Runnable` trait and several macros for running input devices and processors.
//! The `InputDevice` trait provides the interface for individual input devices, and the macros facilitate their concurrent execution.
use core::cell::RefCell;

use crate::channel::KEYBOARD_REPORT_CHANNEL;
use crate::hid::Report;
use crate::keymap::KeyMap;

pub mod adc;
pub mod battery;
pub mod joystick;
pub mod pmw3610;
pub mod rotary_encoder;

/// The trait for runnable input devices and processors.
///
/// For some input devices or processors, they should keep running in a separate task.
/// This trait is used to run them in a separate task.
pub trait Runnable {
    async fn run(&mut self) -> !;
}

/// The trait for input devices.
///
/// This trait defines the interface for input devices in RMK.
/// The `Runnable` implementation (typically generated by macros) drives
/// the loop that reads events and publishes them.
///
/// # Example
/// ```rust
/// // Define an input device
/// struct MyInputDevice;
///
/// impl InputDevice for MyInputDevice {
///     type Event = Event;
///     async fn read_event(&mut self) -> Self::Event {
///         // Input device implementation
///     }
/// }
///
/// // Use the input device
/// let d1 = MyInputDevice{};
/// let d2 = MyInputDevice{};
///
/// // Run all devices simultaneously with RMK
/// embassy_futures::join::join(
///     run_all!(d1, d2),
///     run_rmk(
///         // .. arguments
///     ),
/// )
/// .await;
/// ```
pub trait InputDevice: Runnable {
    /// Read the raw input event
    type Event;
    async fn read_event(&mut self) -> Self::Event;
}

/// The trait for input processors.
///
/// The input processor processes the [`Event`] from the input devices and converts it to the final HID report.
/// Take the normal keyboard as the example:
///
/// The [`crate::matrix::Matrix`] is actually an input device and the [`crate::keyboard::Keyboard`] is actually an input processor.
pub trait InputProcessor<'a, const ROW: usize, const COL: usize, const NUM_LAYER: usize, const NUM_ENCODER: usize = 0>:
    Runnable
{
    type Event;

    /// Process the incoming events, convert them to HID report [`Report`],
    /// then send the report to the USB/BLE.
    ///
    /// Note there might be mulitple HID reports are generated for one event,
    /// so the "sending report" operation should be done in the `process` method.
    /// The input processor implementor should be aware of this.
    async fn process(&mut self, event: Self::Event);

    /// Send the processed report.
    async fn send_report(&self, report: Report) {
        KEYBOARD_REPORT_CHANNEL.send(report).await;
    }

    /// Get the current keymap
    fn get_keymap(&self) -> &RefCell<KeyMap<'a, ROW, COL, NUM_LAYER, NUM_ENCODER>>;
}

#[macro_export]
macro_rules! run_all {
    ($( $dev:ident ),*) => {{
        use $crate::input_device::Runnable;
        $crate::join_all!(
            $(
                $dev.run()
            ),*
        )
    }};
}

/// Macro for binding input processor chain to event channel and running them.
///
/// FIXME: For split keyboard, `EVENT_CHANNEL` is REQUIRED as it's the default channel for receiving events from peripherals.
///
/// This macro creates tasks that receive events from channels and process them using specified processor chains.
/// It calls processors in order and decides whether to continue the chain based on the result of each processor.
///
/// # Arguments
///
/// * `channel`: The channel to receive events from
/// * `procs`: The processor list that will handle the events
///
/// # Example
///
/// ```rust
/// use rmk::channel::{blocking_mutex::raw::NoopRawMutex, channel::Channel, EVENT_CHANNEL};
/// // Create a local channel for processor chain
/// let local_channel: Channel<NoopRawMutex, Event, 16> = Channel::new();
/// // Two chains, one use local channel, the other use the built-in channel
/// let processor_future = run_processor_chain! {
///     local_channel => [processor1, processor2, processor3]
///     EVENT_CHANNEL => [processor4, processor5, processor6]
/// };
/// ```
#[macro_export]
macro_rules! run_processor_chain {
    ( $( $channel:expr => [ $first:expr $(, $rest:expr )* ] ),+ $(,)? ) => {{
        use rmk::input_device::InputProcessor;
        $crate::join_all!(
            $(
                async {
                    loop {
                        let event = $channel.receive().await;

                        // Process the event with the first processor
                        match $first.process(event).await {
                            $crate::input_device::ProcessResult::Stop => {
                                // If the first processor returns Stop, continue to wait for the next event
                                continue;
                            },
                            $crate::input_device::ProcessResult::Continue(next_event) => {
                                // Pass the result to the next processor in the chain
                                let mut current_event = next_event;
                                $(
                                    match $rest.process(current_event).await {
                                        $crate::input_device::ProcessResult::Stop => {
                                            // If any processor returns Stop, continue to wait for the next event
                                            continue;
                                        },
                                        $crate::input_device::ProcessResult::Continue(next_event) => {
                                            // Update the current event and continue processing
                                            current_event = next_event;
                                        }
                                    }
                                )*
                            }
                        }
                    }
                }
            ),+
        )
    }};
}
